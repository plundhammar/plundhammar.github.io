[{"content":"In this post I want to try to reconstruct an image from the simulated data in the previous post. Supposedly the original source consists of two point sources close together around z= -0.5 cm. However, I found it hard to understand the properties of the reconstruction. I will need to redo this simulation with full a priori information about the simulated source.\nSo, I have looked into the reconstruction application Compton_MLEM by Matt Leigh, Ref. [1]. It is written in CUDA Ref. [2], an extension of the C programming language with the ability to specify thread-level parallelism in C. This programming language was new to me, and I had a hard time simply trying to install the necessary software to make everything work (especially the nividia drivers caused me some headache)! I recommend doing the tutorial in Ref. [3] just to get a feeling for the language, and to demystify it. It is very similar to C++, but with some additional methods to parallelize the calculations.\nThe CUDA-program Compton_MLEM reconstructs an image from list-mode data using the Maximum-Likelihood Expectation Maximization Algorithm; an overview of the theory can be found in one of my previous posts.\nNote: The Compton_MLEM does not work with the newest version of CUDA. It seems that the flag sm_30 was deprecated when building the executable, see Ref. [4]. However, simply removing it in makefile works, or at least does not return any errors. That is, in makefile there is one value specifying the flags of the build NVFLAGS = -arch=sm_30 '-std=c++11' which I changed to NVFLAGS = '-std=c++11' and it seems to work.\nIn the repo of Compton_MLEM it seems that the folder /MLEM_NO_MATRIX is both the fastest and the best maintained part of this project. In it there are three main CUDA scripts found in the /Source folder:\nCPUFunctions.cu GraphicsCardFunctions.cu and Parallel_Reform.cu The Parallel_Reform.cu is the main script and allocates memory and jobs between the CPU and GPU through the scripts GraphicCardFunctions.cs and CPUFunctions.cu. I will come back to the functionality of these scripts in the future, there exists some questions regarding the calculation of some values. Using the data in the I tried to reconstruct the source distribution in the cube $X\\times Y\\times Z = [-10,10]\\times [-10,10]\\times [-10,10]~\\mathrm{mm}^3$ in figure 1 and 2. The initial image is the back projected source distribution. It looks kind of strange. I would have guessed that the backprojection would have some symmetry properties along some axis. However, the 150th iteration looks less noisy and more closely like one (two?) point sources.\n(a): The backprojected image initiating the algorithm. (b): The 150th iteration. Figure 1: Slices of the $z$-axis.\n(a): The backprojected image initiating the algorithm. (b): The 150th iteration. Figure 2: Slice of the $z$-axis.\nSince I don\u0026rsquo;t know exactly where the source is placed I can only guess. Looking at figure 1b it seems that we have overestimated the $X$ and $Y$ intervals, perhaps even the $Z$ interval. In figure 3 and 4 I consider the voxel space in $X\\times Y\\times Z = [1.0,1.0]\\times [1.0,1.0]\\times [5.0,5.0]~\\mathrm{mm}^3$.\n(a): The backprojected image initiating the algorithm. (b): The 150th iteration. Figure 3: Zoomed in version of figure 1.\n(a): The backprojected image initiating the algorithm. (b): The 150th iteration. Figure 4: Zoomed in version of figure 2.\nNow it kind of looks like a circle emerges, with no real symmetric properties. I may have misunderstood the algorithm but these results seem strange to me.\nConclusion The Compton_MLEM program returns an image. What exactly I\u0026rsquo;m looking at requires me to understand the CUDA script in depth. I have some queries on how the Klein-Nishina values are calculated but I can\u0026rsquo;t really draw any conclusions as of yet. Furthermore, I do not know exactly where the source is positioned in the list-mode data I have (though this might be more realistic). I will redo this simulation study with another data set where the system parameters are known, and try to catch the logic in the code.\nReferences [1] Compton_MLEM\n[2] CUDA\n[3] https://cuda-tutorial.readthedocs.io/en/latest/tutorials/tutorial01/\n[4] https://forums.developer.nvidia.com/t/ptxas-fatal-value-sm-30-is-not-defined-for-option-gpu-name/163708\n","permalink":"https://plundhammar.github.io/posts/compton_mlem-a-gpu-based-image-reconstruction-application-in-cuda/","summary":"In this post I want to try to reconstruct an image from the simulated data in the previous post. Supposedly the original source consists of two point sources close together around z= -0.5 cm. However, I found it hard to understand the properties of the reconstruction. I will need to redo this simulation with full a priori information about the simulated source.\nSo, I have looked into the reconstruction application Compton_MLEM by Matt Leigh, Ref.","title":"`Compton_MLEM`, A GPU-Based Image Reconstruction Application in CUDA"},{"content":"The energies of a Compton scatter chain are correlated through the Compton scattering equation as well as the Klein-Nishina distribution. This means that some vital statistics must exist, and perhaps be possible to calculate in closed expression. In this post I wanted to give it a try and compare it to some simulated data.\nI recently got a hold on some simulated list-mode data of photons interacting with a silicon volume. That is, a list $$ [\\mathbf{r}_1,E_1,\\mathbf{r}_2,E_2] $$\nof\ninteraction position $\\mathbf{r}_1$ of Compton event with the deposited energy $E_1$ of the scattered electron and the interaction position $\\mathbf{r}_2$ of either a photoabsorption or another Compton scatter event following the first scattering event, with the corresponding deposited energy $E_2$ of the scattered electron. Something that occurred to me was that basically all of the statistics are known in this problem. That is, for a scatter series as in figure 1 we have that Ref. [1] $$ E_\\gamma\u0026rsquo; = \\frac{E_\\gamma}{1+\\varepsilon(1-\\cos\\theta)} $$\nwith $\\theta$ being the scatter angle and $\\varepsilon = E_\\gamma\u0026rsquo;/E_\\gamma$, and canonical for $E_\\gamma\u0026rsquo;\u0026rsquo;$ with $\\theta\u0026rsquo;$ and $\\varepsilon\u0026rsquo;$ defined similarly to above.\nFigure 1: A serie of two scatter events.\nSince the scatter angle is inherently stochastic with a probability density function given by a function $\\mathrm{pr}(\\cos\\theta)$ proportional to the Klein-Nishina distribution, Ref. [2], i.e. $$ \\mathrm{pr}(\\cos\\theta)\\propto \\frac{1}{1+\\varepsilon(1-\\cos\\omega)}\\left(\\frac{1}{1+\\varepsilon(1-\\cos\\omega)}+1+\\varepsilon(1-\\cos\\omega-(1-\\cos^2\\omega))\\right). $$ That means that we can calculate the moments of $E_\\gamma\u0026rsquo;$ and $E_\\gamma\u0026rsquo;\u0026rsquo;$. For instance, $$ \\mathbb{E}\\left[E_\\gamma\u0026rsquo;\\right] = E_\\gamma\\int_{-1}^1\\mathrm{d}(\\cos\\theta)\\frac{\\mathrm{pr}(\\cos\\theta)}{1+\\varepsilon(1-\\cos\\theta)}. $$ For $\\varepsilon = 1$, i.e. $E_\\gamma = 511~\\mathrm{keV}$, we can calculate the expectation value of the deposited energy $E_1$: $$ \\mathbb{E}\\left[E_1\\right] = 511\\times\\left[\\frac{\\log(3)-\\frac{28}{81}}{\\frac{40}{9}-\\log(3)}\\right]~\\mathrm{keV} \\approx 511\\times 0.656\\mathrm{keV}\\approx 335\\mathrm{keV} $$ For a given $E_\\gamma\u0026rsquo;$ we can calculate the expectation value and standard deviation of $E_\\gamma\u0026rsquo;\u0026rsquo;$ in the same manner as above. I got some data simulating the setup in figure (2).\nFigure 2: Geometry of the simulation.\nThe events are the positions and energies as described above, and illustrated in figure (3)\nFigure 3: The events in the silicon solid.]]\nIn figure (4) the simulated data is shown together with the expectation value (red line) and one standard deviation away from the expectation value (blue lines) as well as the line where photo absorption happens (gray).\nFigure 4: Energy distribution of some simulated list-mode data and its statistics.]]\nNote that the realizations get denser at $E_1 = 335~\\mathrm{keV}$, as calculated above.\nConclusion The result in figure 4 looks kind of right. However, I implicitly assume that $E_1$ is given when calculating the expectation value of $E_2$. This is of course true, since the events are causal. What could have been taken into consideration is the distribution of $E_1$ and subsequently how the pair $(E_1,E_2)$ is distributed in the energy space. I could have gone further in the statistics, and maybe I will in the future, but I will leave it like this for now.\nReferences [1] A. H. Compton 1923 A Quantum Theory of The Scattering of X-Rays by Light Elements Phys. Review 21.5 483-502, Link\n[2] Klein O and Nishina Y 1929 Uber die Streuung von Strahlung durch freie Elektronen nach der neuen relativistischen Quantendynamik von Dirac Z Phys. 52 853–69, Link\n","permalink":"https://plundhammar.github.io/posts/properties-of-list-mode-data-of-a-compton-camera/","summary":"The energies of a Compton scatter chain are correlated through the Compton scattering equation as well as the Klein-Nishina distribution. This means that some vital statistics must exist, and perhaps be possible to calculate in closed expression. In this post I wanted to give it a try and compare it to some simulated data.\nI recently got a hold on some simulated list-mode data of photons interacting with a silicon volume.","title":"Properties of List-Mode data from a Compton Camera"},{"content":"The List-Mode Maximum Likelihood Expectation Maximization (LM-MLEM) algorithm is widely used in Compton camera reconstruction. It\u0026rsquo;s well suited for the list-mode data architecture and easy to parallelize. This post will be somewhat technical and a sort of summary of the main arguments found in the litterature.\nThe problem has been stated many times, Ref.[1-8]. I will state it as follows (I will use the same notation as in Ref.[8]), and the proof of it will be the subject of a future post:\nLet $\\lambda$ be the mean and variance of the Poisson distribution of some source. The following sequence converges to $\\lambda$: $$ \\widehat{\\lambda}_j^{l+1} = \\frac{\\widehat{\\lambda}_j^{(l)}}{s_j}\\sum_{i=1}^N t_{ij}\\frac{1}{p_i^{(l)}}~~\\text{with}~~p_i^{(l)} = \\sum_{k=1}^M t_{ik}\\widehat{\\lambda}^{(l)}_k $$ where\n$t_{ij}$ are elements of the system matrix, indexed on the events $i$ and voxels $j$; $s_j=\\sum_i t_{ij}$is the sensitivity correction. The initialization step consists in calculating $\\widehat{\\lambda}^{(0)}$, generally as the back-projection in the image volume of the $N$ events. The question is now what the system matrix is. Probabilistic Model of the System Matrix Let $x$ be the vector of coordinates of a point $M$ from the source. The probability of occurrence of the measured event $y$ given that $\\mathfrak{p}$ was emitted at $x$ is given by\n$$ p_{Y:X}(y:x,E_0) = \\int p_{Y:\\tilde{Y}}(y:\\tilde{y},E_0)p_{\\tilde{Y}:X}(\\tilde{y}:x,E_0)\\textrm{d}\\tilde{y}. $$\nThis is a trick found in statistical physics, and it can be seen as a variant of the Chapman–Kolmogorov equation Ref. [9]. We will now argue for what properties the two probability distributions $p_{Y:\\tilde{Y}}(y:\\tilde{y},E_0)$ and $p_{\\tilde{Y}:X}(\\tilde{y}:x,E_0)$ should have.\nConsidering $p_{Y:\\tilde{Y}}(y:\\tilde{y},E_0)$, this distribution could be summarized to have the task of answering the following question\nHow likely is it that the measured event $y$ was registered given that the real event $\\tilde{y}$ happened? Since the measurement is based on the measurement and real event of the position in the first and second scatterer, as well as the measurement and real event of the scattering angle which we may assume to be independent we have\n$$ p_{Y:\\tilde{Y}}(y:\\tilde{y},E_0) =p_{V_1:\\tilde{V}_1}(V_1:\\tilde{V_1},E_0)p_{V_2:\\tilde{V}_2}(V_2:\\tilde{V}_2,E_0)p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta},E_0). $$\nThe terms $p_{V_i:\\tilde{V}_i}(V_i:\\tilde{V_i},E_0)$ depends on the spatial resolution of the detector and something that we may impose depending on the detector design. The term $p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta},E_0)$ depends on the energy resolution of the detectors, since the measured scattering angle $\\beta$ is calculated through an energy dependent relation (Compton scattering with additional corrections perhaps). Now considering $p_{\\tilde{Y}:X}(\\tilde{y}:x,E_0)$, it is the product of several probabilities:\nThe probability of the Compton scattering process (including Doppler-broadening);\nAbsorption probabilities (in the different environments such as the object, air, absorption of the scattered photon in the scatter detector);\nThe absorption probability of the photon in the absorber;\nThe solid angle subtended at the origin of the particle $M$ by the detector element containing the first hit, which should be considered in 3D since the emission is isotropic, and on the solid angle subtended at the position of the first hit by the detector element where the second hit takes place, which should be considered in 2D since it is related to a cone surface uncertainty through the scattering angle.\nThe probability of the Compton scattering process is proportional to the Compton scattering cross-section given by the Klein-Nishina distribution, denoted $K(\\tilde{\\beta}:E_0)$ at energy $E_0$.\nIn general a solid angle considered in 3D may be written as $A/r^2$ where $A$ is the sector of the sphere of radius $r$ that the half-angle covers. Similarly, in 2D it may be written $A/r$ with the same definition. So, the solid angle subtended at the origin of the particle at $M$ can be written\n$$ \\frac{1}{\\tilde{V}_1M^2}\\int_{S_{\\tilde{V}_1M}}\\textrm{d}S\\propto \\frac{1}{\\tilde{V}_1M^2}\\int_{-\\theta_{\\tilde{V}_1M^2}}^{\\theta_{\\tilde{V}_1M^2}}\\sin(\\theta)\\textrm{d}\\theta \\propto \\frac{\\cos(\\theta_{\\tilde{V}_1M})}{\\tilde{V}_1M^2}. $$\nSimilarly, the solid angle subtended at the position of the first hit by the detector element where the second hit takes place is proportional to $$ \\frac{\\cos(\\theta_{\\tilde{V}_1\\tilde{V}_2})}{\\tilde{V}_1\\tilde{V}_2}, $$ since we now consider it in 2D. Ignoring absorption probabilities (see Ref. [10,11] for a discussion of this), we can now write\n$$ p_{\\tilde{Y}:X}(\\tilde{y}:x,E_0)\\propto K(\\tilde{\\beta}:E_0)\\frac{\\cos(\\theta_{\\tilde{V}_1M})}{\\tilde{V}_1M^2}\\frac{\\cos(\\theta_{\\tilde{V}_1\\tilde{V}_2})}{\\tilde{V}_1\\tilde{V}_2} $$\nIf the real positions are known (there in reality unobservable) $\\tilde{\\beta}$ can be calculated geometrically, let $\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}$ denote the geometrically obtained scattering angle. This may be estimated by measured values of the deposed energies and incident energy of the incident photon by $$ \\cos(\\beta) = 1 - \\frac{m_e c^2E_1}{E_0(E_0-E_1)} $$ with $m_ec^2$ begin the mass energy of the electron. Inserting these probabilities and integrating results in\n$$ p_{Y:X}(y:x,E_0) = \\int p_{Y:\\tilde{Y}}(y:\\tilde{y},E_0)p_{\\tilde{Y}:X}(\\tilde{y}:x,E_0)\\textrm{d}\\tilde{y} $$ $$ =\\int_{\\mathbb{R}^3}\\frac{\\cos(\\theta_{\\tilde{V}_1M})}{\\tilde{V}_1M^2}p_{V_1:\\tilde{V}_1}(V_1:\\tilde{V_1},E_0) $$ $$ \\times\\int_{\\mathbb{R}^3}\\frac{\\cos(\\theta_{\\tilde{V}_1\\tilde{V}_2})}{\\tilde{V}_1\\tilde{V}_2}p_{V_2:\\tilde{V}_2}(V_2:\\tilde{V}_2,E_0) $$ $$ \\times K(\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}:E_0)p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M},E_0)\\textrm{d}\\tilde{V}_2\\textrm{d}\\tilde{V}_1 $$\nWe will assume that the uncertainty on the direction of the Compton cone axis may be considered as negligible compared to the uncertainty of the measured Compton scattering angle. Consequently, the real and measured points where $\\mathfrak{p}$ hits the detector may be merged, leading to the simplified formulation: $$ p_{Y:X}(y:x,E_0) =\\frac{\\cos(\\theta_{{V}_1M})}{{V}_1M^2}\\frac{\\cos(\\theta_{{V}_1{V}_2})}{{V}_1{V}_2}K(\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}:E_0)p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M},E_0) $$\nThe element $t_{ij}$ of the system matrix $T$ is defined as:\nthe probability of observing the physical event $y_i$ when a photon is emitted by the voxel $v_j$. With our notation this may be written\n$$ t_{ij} =\\int_{v_j} p_{Y_i:X}(y_i:x,E_0)p(x:M\\in v_j)\\textrm{d}x $$\n$$ =\\frac{1}{\\textrm{vol}(v_j)}\\int_{v_j} p_{Y_i:X}(y_i:x,E_0)\\textrm{d}x $$\nwhere $p(x:M\\in v_j)$ is the probability that the physical event took place in $v_j$, and assuming that a voxel is sufficiently small to allow a constant probability inside the voxel. With the expression for $p_{Y_i:X}(y_i:x,E_0)$ we get\n$$ t_{ij}= \\frac{1}{\\textrm{vol}(v_j)}\\frac{\\cos(\\theta_{{V}_1{V}_2})}{{V}_1{V}_2}\\int_{v_j} \\frac{\\cos(\\theta_{{V}_1M})}{{V}_1M^2}K(\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}:E_0)p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M},E_0)\\textrm{d}x $$\nThe only remaining thing is to model the probability $p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M},E_0)$, which describes the uncertainty of the measurement of the scattering angle, $\\beta$. For an ideal detector this probability would be\n$$ p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M},E_0) = \\delta(\\beta-\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}). $$\nFor a finite resolution detector, a convenient choice may be the Gaussian distribution with mean $\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}$ and standard deviation $\\sigma_{\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}}$,\n$$ p_{\\beta:\\tilde{\\beta}}(\\beta:\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M},E_0) = \\frac{1}{\\sigma_{\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}} \\sqrt{2\\pi}}\\exp\\left[\\frac{(\\beta-\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M})^2}{2\\sigma^2_{\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}}}\\right]. $$\nThe unknown mean $\\tilde{\\beta}_{\\tilde{V}_1,\\tilde{V}_2,M}$ may be replaced by the measured value $\\beta$. The standard deviation can be calculated frm the knwn detector uncertainties $\\sigma_{\\tilde{E}_1}$ and $\\sigma_{\\tilde{E}_2}$ as:\n$$ \\sigma_{\\tilde{\\beta}} = \\frac{m_ec^2}{E_0^2\\sin(\\tilde{\\beta})}\\sqrt{\\sigma_{\\tilde{E}_1}^2+\\frac{\\tilde{E}_1^2(\\tilde{E}_2+E_0)^2}{\\tilde{E}_2^4}\\sigma_{\\tilde{E}_2}^2} $$\nIt may be seen from the iterative equation above that the factor multiplying the integral in the equation for the system matrix element gets canceled in the iterative reconstruction process and may thus be ignored.\nEven though the sensitivity matrix is given by the system matrix it is often approximated to something easier to calculate since the proper definition of the sensitivity matrix is usually a bottleneck in computation.\nConclusions The LM-MLEM algorithm seems to be fruitful when considering the reconstruction problem of Compton cameras. Understanding the theory is an essential first step to understanding the practicalities of this algorithm. It is the case, as I have experienced, that when implemented naively, this algorithm is very computationally heavy. However, there are smart ways of going about it and the LM-MLEM algorithm have certain properties that makes it very efficient in the right framework.\nReferences Feng, et al. 3-D Reconstruction Benchmark of a Compton Camera Against a Parallel-Hole Gamma Camera on Ideal Data. IEEE Transactions on Radiation and Plasma Medical Sciences\nLehner, et al. 4pi Compton Imaging Using 3-D Position-Sensitive CdZnTe Detector Via Weighted List-Mode Maximum Likelihood. IEEE Transactions on Nuclear Science. Link\nLange, et al. EM Reconstruction Algorithms for Emission and Transmission Tomography.\nWilderman, et al.Improved Modeling of System Response in List Mode EM Reconstruction of Compton Scatter Camera Images. IEEE Transactions on Nuclear Science Link\nCucci et al. List-mode MLEM Image Reconstruction from 3D ML Position Estimates. IEEE Nuclear Science Symposuim \u0026amp; Medical Imaging Conference. Link\nWilderman et al. List-Mode Maximum Likelihood Reconstruction of Compton Scatter Camera Images in Nuclear Medicine. 1998 IEEE Nuclear Science Symposium Conference Record. 1998 IEEE Nuclear Science Symposium and Medical Imaging Conference (Cat. No.98CH36255). Link\nCaucci, et al. Maximum Likelihood Event Estimation and List-mode Image Reconstruction on GPU Hardware.IEEE Nuclear Science Symposuim \u0026amp; Medical Imaging Conference. Link\nVoichita Maxim, et al. Probabilistic models and numerical calculation of system matrix and sensitivity in list-mode MLEM 3D reconstruction of Compton camera images Phys.Med.Biol. 61 243. Link\nChapman-Kolmogorov Equation\nWilderman, et al. List-mode maximum likelihood reconstruction of Compton scatter camera images in nuclear medicine Nuclear Science Symp. Conf. Rec. 3 1716–20\nParra. Reconstruction of cone-beam projections from Compton scattered data. IEEE Transactions on Nuclear Science. 47.4. 1543-1550 Link\n","permalink":"https://plundhammar.github.io/posts/understanding-the-system-matrix-and-the-lm-mlem-algorithm/","summary":"The List-Mode Maximum Likelihood Expectation Maximization (LM-MLEM) algorithm is widely used in Compton camera reconstruction. It\u0026rsquo;s well suited for the list-mode data architecture and easy to parallelize. This post will be somewhat technical and a sort of summary of the main arguments found in the litterature.\nThe problem has been stated many times, Ref.[1-8]. I will state it as follows (I will use the same notation as in Ref.[8]), and the proof of it will be the subject of a future post:","title":"Understanding the System Matrix and the LM-MLEM Algorithm"},{"content":"Delving into the practicalities of the inverse problem of reconstructing Compton camera images will lead you to Legandre polynomials or Maximum Likelihood methods, most likely.\nSince last week I have been interested in both the analytical reconstruction techniques as well as some of the iterative methods.\nRegarding iterative methods, what I found is that it is difficult to get a feeling on how the iterative methods properly work simply because the algorithms (I write mine in Python) is increadibly slow. However, I have made some progress and have been able to reproduce some results but in a very corse voxel space. One way of simplifying things is to simplify the system matrix. I was reading Ref. [1] where they sort of reduce the forward problem to the following statement:\nThe probability of observing a given measurement $$ A_i = [E_0,E\u0026rsquo;,r_{01},r_{12}] $$ given a gamma ray incident from pixel $j$ is $$ t_{ij} = \\exp(-\\sigma_t(E_0)r_{01})\\frac{\\mathrm{d}\\sigma_C}{\\mathrm{d}\\Omega}\\exp(-\\sigma_t(E\u0026rsquo;)r_{12}), $$ where $\\sigma_t(E)$ is the total absorbtion cross section at energy $E$, $E_0$ and $E\u0026rsquo;$ the initial and scattered gamma-ray energies, respectively, $r_{01}$ the attenuation distance between the first and second interactions, and $\\mathrm{d}\\sigma_C/\\mathrm{d}\\Omega$ the Compton corss section divided by $r_{12}^2$.\nBasically you could write a function calculating the values $\\sigma_t(E)$ and $\\mathrm{d}\\sigma_C/\\mathrm{d}\\Omega$ and the distances on the fly without storing the values in huge matrices. I think this approach could be fruitful.\nThe computational complexity of the list-mode likelihood methods are a huge issue still. However, being clever like in Refs. [2] \u0026amp; [3], one can speed up these types of algorithms by a factor of 250(!) by running it on a 8 GPU units.\nAn interesting counterpart to the iterative modeling is the analytical methods. I read Ref. [4], where they derive all nessecery properties , like the point spread function and deconvolution kernel, to be able to fully (at least in theory disregarding numerical issues) reconstruct any image obtained from Compton camera event data. They start with the following statement:\nThe probability distribution $p(\\omega)$ of measuring an event with scatter angle $\\omega$ is proportional to the differential cross-section, $h(\\cos\\omega)$.\nNote that we are ignoring spatial and energy resolution of the detector as well as absorption probabilities within the detector. This model is a perfect study to understand the mathematical issues arising from the geometry of the Compton camera. They conclude, like in Ref. [5], that simply applying a spherical deconvolution will not work. Specifically, consider the model $$ f(\\Omega_2) = \\int\\mathrm{d}\\Omega_1 g(\\Omega_1)h(\\cos\\omega) $$ where $f(\\Omega_2)$ is the measured image intesity summed over all measured scatter angles and using the statement above. One might be tempted to try to invert this equation directly, and it is accually possible! The show in the Appendix A that there exists an $h^{-1}(\\cos\\omega)$ such that $$ g(\\Omega_1) = \\int \\mathrm{d}\\Omega_2 f(\\Omega_2)h^{-1}(\\cos\\omega) $$ where $$ h^{-1}(\\cos\\omega) = \\sum_{n=0}^\\infty \\left(\\frac{2n+1}{4\\pi}\\right)\\frac{P_n(\\cos\\omega)}{H_n} $$ and $$ H_n = \\frac{2n+1}{2}\\int\\mathrm{d}(\\cos\\omega)h(\\cos\\omega)P_n(\\cos\\omega) $$ and the basis function $P_n(\\cos\\omega)$ are Legandre polynomials. However, this solution is not stable since the coefficient $H_n$ approach zero, and since they are in the denominator in the expression for $h^{-1}(\\cos\\omega)$ this function is not stable. What they do is to define the summation image $g\u0026rsquo;(\\Omega\u0026rsquo;_1)$ which they prove can be expressed by an angular convolution of the line projections with an appropriate point spread function. Then one can reconstruct $g(\\Omega_1)$ from $g\u0026rsquo;(\\Omega_1\u0026rsquo;)$. The point spread function, called $h_{bp}(\\cos\\omega)$ is then derived and the result is $$ h_{bp}(\\cos\\omega) = \\frac{1}{\\sqrt{1-\\cos^2\\omega/2}}\\int_{-\\cos\\omega/2}^{\\cos\\omega/2}\\mathrm{d}z\\frac{h(z)}{\\sqrt{\\cos^2\\omega/2-z^2}}, $$ with $$ h(\\cos\\omega) = h_c(\\cos\\omega)\\frac{1+\\cos^2\\omega+\\frac{\\gamma^2(1-\\cos\\omega)^2}{1+\\gamma(1-\\cos\\omega)}}{(1+\\gamma(1-\\cos\\omega))^2} $$ and $h_c(\\cos\\omega)$ being the Klein-Nishima cross-section, see figure 1. The angle $\\omega$ in the expression above is the angle from a $z$-axis between the axis of the source point and the axis of the cone.\nFigure 1: $h_c(\\cos\\omega)$\nThe differential cross section convolution kernel $h(\\cos\\omega)$ can be seen in figure 2.\nFigure 2: $h(\\cos\\omega)$\nThey said that the integral above has an analytic solution but when I triend to calculate it in scipy it did not result in anything. I did manage to replicate the resulting point spread function, see figure 3.\nFigure 3: $h_bp(\\cos\\omega)$\nIt would be interesting to expand this in Legandre polynomials and deconvolve the measured image intesity summed over scattering angles and compare with an iterative method like LM-MLEM. I suppose the system matrix would take the simple form above shown in Ref. [1], if I manage to write efficient code.\nConclusion Iterative methods are probably the best but they are very computationaly heavy. For a toy model, one could try to simplify the system matrix to just a few calculation for each element.\nAnalytical methods are simple in there assumptions but can easily be expanded upon. Aslo, they are fast and efficient. It seems that the best approach is to expand some transformed version of the point spread function in Legandre polynomials, such that the expansion coefficients are far from zero. Then deconvolve the source responce with the expression of the inverse transformed point spread function.\nReferences [1] 4$\\pi$ Compton Imaging Using 3-D Position-Sensitive CdZnTe Detector Via Weighted List-Mode Maximum Likelihood, Lehner, C.E; He, Zhong; Zhang, Feng Link\n[2]Maximum Likelihood Event Estimation and List-mode Image Reconstruction on GPU Hardware, Caucci, Luca; Furenlid, Lars R.; Barrett, Harrison H. Link\n[3] List-mode MLEM Image Reconstruction from 3D ML Position Estimates, Caucci, Luca; Furenlid, Lars R.; Barrett, Harrison H. Link\n[4] Reconstruction of cone-beam projections from Compton scattered data, Parra L.C Link\n[5] Application of spherical harmonics to image reconstruction for the Compton camera, Basko, Roman; Zeng, Gengsheng L; Gullberg, Grant T Link\n","permalink":"https://plundhammar.github.io/posts/deconvolution-and-system-matrices/","summary":"Delving into the practicalities of the inverse problem of reconstructing Compton camera images will lead you to Legandre polynomials or Maximum Likelihood methods, most likely.\nSince last week I have been interested in both the analytical reconstruction techniques as well as some of the iterative methods.\nRegarding iterative methods, what I found is that it is difficult to get a feeling on how the iterative methods properly work simply because the algorithms (I write mine in Python) is increadibly slow.","title":"Deconvolution and the System Matrix"},{"content":"One of the first properties encountered in Compton camera image reconstruction is the cone-surface projection. Understandig the properties of this geometrical object will set the ground works for understanding more advanced models.\nI was reading some articles of the early versions of the Compton camera image reconstruction procedure when I came across Ref.[1] talking about the cone-surface projections. They investigated a primitive version of a \u0026lsquo;\u0026lsquo;Compton camera\u0026rsquo;\u0026rsquo;. Well, it kind of had some properties like a Compton camera like a scatterer and an absorber but they assumed that photons only scatter at a fixed given angle. This camera measures the cone-surface projection of a source. What this means is that the intensity measured at a given detector is proportional to the integral over the intersection of the cone and the source, given that the source is homogeneous. Specifically, let $f(\\mathbf{x})$ denote the source distribution, $\\mathbf{k}$ the cone axis making angle $\\beta$ with $\\mathbf{n}$ along the cone surface, they defined\n$$ p(\\mathbf{n}) = \\int_0^\\infty f(O+\\mathbf{n}r)r\\mathrm{d}r~~~~~~q_k(\\beta) = \\int_{S(\\mathbf{k},\\beta)}p(\\mathbf{n})\\mathrm{d}s. $$ Here $S(\\mathbf{k},\\beta)$ denotes the circle created by intersecting the cone with axis $\\mathbf{k}$ and half-angle $\\beta$ with the unit sphere, and $O$ the apex of the cone, describing the first interaction point with the scatterer. The quantity $q_{k}(\\beta)$ is the cone-surface projection. It is reasonable that the cone-surface projections are at least proportional to the photon flux at the detector for a given scattering angle and cone axis.\nNow, they showed a method to invert these equations to obtain the original source $f(\\mathbf{x})$ via Legendre transforms. However, they also showed a figure in which these cone-surface projections were shown (figure 1). I wanted to try to recreate this figure.\nFigure 1: The first two steps of image reconstruction. (a) Plane projections calculated directly from the phantom (b) Cone-surface projections (c) Plane projections evaluated by the algorithm from cone-surface integrals.\nThe cone-surface projections in (b) are calculated for scattering angle $\\beta = \\pi/4$, but they do not entail what cone axis is used or how it is chosen or how the sphere phantom is placed in the space.\nProblem Statement I wanted to generate figure 1 (b), and what I can gather from the article we have:\nA spherical phantom with a radius of 10 mm offset some distance from the rotation axis (not given but looks like around 20 mm from figure 1 (a)); Since they do not talk about specific detector elements I assume that they use all voxels along an axis in the plane perpendicular to the rotation axis. I will however define a set of detector elements along this axis; The cone-surface projection is then the total contribution of a cone with half-angle $\\beta = \\pi/4$ with some axis $\\mathbf{k}$ (not explicitly given but I will take the one perpendicular to the rotation axis) with the spherical source. Practical Issues and Result In Python I made two classes: voxelSpace and detectorSpace. The voxelSpace class handles the discretization of 3D space, which I call computational space, and places a sphere with some offset to the rotation axis in the computational space. In practice it associates the number 0 for each voxel outside the sphere and 1 for each voxel inside the sphere. The detectorSpace class handles the detector geometry and all functions needed to calculate the intersection of the cone with the sphere. I calculated the intersection the same as the method presented in Ref. [2].\nThe first program prototype was fantastically slow and would not yield anything. Some rewriting and parallelizing the code with the help of Ref. [3,4] made it much faster but still incredibly slow. I thought it was the rotation that took the longest so I wrote a separate rotation method based on Ref. [5]. In the end I could produce figure (2).\nFigure 2: Left - The phantom sliced in the middle. Middle - The ordinary Radon projection. Right - The cone-surface projections.\nConclusion Well, the generated cone-surface projection in figure 2 look kind of similar to the ones in figure 1, if I squint. The image in figure 1 was produced for a very rough voxel grid and very few detectors. It took around 20 seconds to get the image in figure 2. The Python code that I wrote scales very poorly. Increasing the resolution of the voxel grid to twice the resolution in figure 2 takes approximately four times as long to calculate.\nI think the main bottleneck is the indicator function in the detectorSpace class, which is based on the one in Ref. [2]. It check each voxel that is touched by the sphere and determines if that voxel also is contained on the surface of the sphere. I do not know how to do it more efficiently at this moment but I think this is where one should look for improvements first.\nThe code is available on my Github account\nReferences [1] Application of spherical harmonics to image reconstruction for the Compton camera, Basko, Roman; Zeng, Gengsheng; Gullberg, Grant T, Link\n[2] A model of spatial resolution uncertainty for Compton camera imaging, Yanting Ma , Joshua Rapp, Petros Boufounos, Hassan Mansour, Link\n[3] Parallel programming in Python - multiprocessing (Pool and apply_async methods), Xin Li, Link\n[4] Parallel programming in Python - multiprocessing (Process and Queue), Xin Li, Link\n[5] Rotation of Voxels in 3D Space using Python, Kok Wei Chew, Link\n","permalink":"https://plundhammar.github.io/posts/cone-surface-projection-in-practice/","summary":"One of the first properties encountered in Compton camera image reconstruction is the cone-surface projection. Understandig the properties of this geometrical object will set the ground works for understanding more advanced models.\nI was reading some articles of the early versions of the Compton camera image reconstruction procedure when I came across Ref.[1] talking about the cone-surface projections. They investigated a primitive version of a \u0026lsquo;\u0026lsquo;Compton camera\u0026rsquo;\u0026rsquo;. Well, it kind of had some properties like a Compton camera like a scatterer and an absorber but they assumed that photons only scatter at a fixed given angle.","title":"Cone-Surface Projections"}]